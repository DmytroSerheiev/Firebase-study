Firestore Data Modeling Course in Cloud Firestore 
Read - (читання масивів)запит  даних із колекції Firestore. Читання масивів промісів

Query - (грубокажучі фільтр)запит у визначеному порядку або фільтр.
За лімітом, за датою, або у зворотному напрямку.
Місце-оператори (більше, менше і так далі), порівняння == . Можна об'єднувати запити та краще робити маленькі прості запити, також можна перевіряти лише масив

Indexes - (пошук помилок по індексу)запит за допомогою індексів, індекси можно робити не відразу а після того як в них буде потреба, коли при запиті в консолі побачиш помилку при запиті індексу
Security - створення декількох колекцій з різними правами доступу 
Cardinality - концепція колекцій на прикладі колекцій книг
One-to-One - один идентификатор авторизації для двох документів, але другий документ неможливо прочитати поки не прочитаешь перший і не отримаєш ідентифікатор другого документу
One-to-Many - масив карт у батківський елемент(важко запитати всі книги одразу), другий варіант - додати спільний фільтр для всіх під колекцій (наприклад автор)
Many-to-Many -  Часто використовується. Найчастіший спосіб , колекція посередників з ідентифікатором, наприклад запитаємо спочатку колекцію за індикатором для відгуків, а потім за ідентифікатором користувачем, тобто ти створюєш категорію по якій будеш фільтрувати
Duplication - дублювання ім'я користувача в коментарі, тепер ми бачимо всю інформацію про користувача і не потрібно читати всю колекцію, це погано якщо у користувача дуже багато коментарів і їх потрібно буде міняти
Aggregation - використання хмарної функції для підрахунку загальної суми покупок або лайків
Votes  - це база даних Firestore, яка зберігає дані про голосування на веб-сайті або додатку
Role-Based Authorization - це процес визначення дозволів користувача на основі ролі
Access Control List - список контролю доступу, коли контент сам визначає доступ користувача, наприклад, доступ до повідомлення по id
Hierarchy - корисний для глибоко вкладеного контенту, можна звертатися до рівня вкладеності за його ідентифікатором або до батьківського елементу і бачити всі рівні, якщо виставити діапазон вкладеностей, який хочеш
Follower Feed - сортування масиву повідомлень за датою останньої публікації
Collection Group Queries
in May of 2019 shortly after this course was originally produced firebase released a new feature that adds some flexibility to sub collection queries this new feature is called a collection group query and it allows you to make a query across multiple sub collections at the same time as long as the sub collection shares the same name this makes it a lot easier to model certain types relationships in a sub collection especially a one-to-mani relationship consider this example here where we have a root authors collection and then also a root books collection in order to manage the relationship on every book document this allows us to make a query of all books that equal a certain author ID and the reason this is commonly kept as a root collection and not a sub collection is because you might also want to make a query of all books that were published on a certain date now prior to May 2019 that just wasn't possible in a sub collection but now that we have collection group queries it is possible now the root collection approach works perfectly fine so you don't need to go and change your existing data models but a sub collection might be a better approach and a lot of situations because you don't need to manually save the parents ID on every single document and it also just provides a more natural hierarchy in the database at large then you feature that makes this all possible is the collection group query and it works just like a regular collection query except that it will grab all the Collections that share a similar ID in Our Data model we have a collection called books nested under every single author so it's going to find all of the books collections and then it will query them based on the same logic that you would do with a normal query so this basically allows you to take all of the sub collections called books and then combine them into a single query so this is a special useful for things like comments where you have multiple blog posts and you have comments nested as a sub collection under each post 90% of the time you probably just want to read the comments under the post itself but you might also want to make a collection group query to get all the comments from a certain user across all the posts in the database



















Resources
a couple things you need first of all you'll need a firebase project and you want to make sure you have firestore enabled as your database in that project in many of the examples we'll be looking at the actual queries that we use to access the data in the database all that code is written in Javascript and you can find these Source Code in the github link below even though the queries are written in Javascript they're very similar for other languages like Swift or kotlin or dart if you're using flutter a lot of developers will be using firebase with a supporting library like angular fire or viewfire on the web so I'm going to keep this Source Code is simple as possible so you can modify the queries to work with whatever language or framework that you're using in fact I would recommend that you follow along with this video using your framework or language of choice then use the JavaScript code as a guide to point you in the right direction but if you do want to follow along with the vanilla JavaScript you can clone the repo and then add your firebase credentials to the config.js file in addition to the resources on fireship IO I also have a couple of articles on angular firebase.com that covered data modeling these articles are written when firestore was in beta but there's still relevant for the most part the firebase team also recently released a video series called getting to know cloud firestore if you haven't seen that already I highly recommend watching it that video series will have some overlap with this course but we'll be pushing things a lot farther and another resource I recommend is just data modeling articles on mongodb there's a lot of articles out there and I'm not going to recommend anything specific but mongodb sure is a lot of similarities with Firestorm so a lot of the data modeling Concepts apply they're both document oriented databases so at a very high level we can apply a lot of the same Concepts even though they're not a perfect one to one comparison and lastly the cloud firestore documentation is very thorough and very good it's very limited on data modeling which is one of the reasons I'm making this course but make sure to bookmark it for whatever language or framework you're using so those are the resources you'll want to have by your side for this course in the next video we'll look at what firestore actually is

intro-what-is-firestore
when firebase was founded all the way back in 2011 it was designed to be a service for mobile applications for building chat applications but what the founders and developers realized is that people were using it for more than just chat applications and using it as a real-time database in general around the same time JavaScript frameworks like angularjs were starting to take off and there was kind of a gold rush going on with native app development for iOS and Android because of this developers needed to focus on optimizing the user experience with front end development services like firebase took off because it allowed users to easily create real-time applications without all of the back end configuration that goes along with it over the next few years firebase continued to grow and it was eventually acquired by Google and October of 2014 now the original database environments was the real-time database it's still a great product and it's not deprecated and not going anywhere and it's actually superior to firestore in certain use cases which will look at here later in the course but it has some limitations that really frustrated developers the database itself is basically just like a giant json object and you can select data at different nodes in this object but the main issue is that you cannot select a subset of this data so if you have a lot of data say 100 megabytes nested below a parent object you would have to pull all that data when reading the parent and then the second issue is that the querying and sorting of data is relatively limited so even if you denormalize your data to solve the first problem you'd still be in a situation where you have to write a lot of client side code to handle things like sorting and filtering of data cloud firestore was created to address these issues it's a document oriented database which is based off of Google's data store database technology which is used in all kinds of Google products like Gmail for example so firespur basically takes the real-time nature of the real-time database think combines it with more practical and flexible data access patterns firestore itself is a document oriented database similar to mongodb first we have collections and collections are just a container that hold documents a collection itself doesn't contain any data it just a name or a path to its location all of the actual data that we're going to use in our applications is contained in the document a document is basically just an objective data that has a unique ID and to access that data we can just read the document directly or we can query a subset of documents based on some shared properties and another unique characteristic of Firestorm is that we can nest collections underneath documents the result is that we have this alternating pattern of collections and documents and when we read a parent document that read a shallow so we don't have to pull in all the data contained in that child collection and that essentially forces us to model data that's efficient to read on the front end the maximum size of an individual document is one megabyte that gives you a lot of room to model your data but at the same time it prevents you from making inefficient queries that send a huge payload of data over the network that's how the overall database is structured but firestore also provides a mechanism for you to handle security I'm not going to cover how to write security rules in detail in this course but we will be talking about how to model data around security concerns you can view the rules here under the rules tab and I'd recommend just keeping your database in a completely unlocked mode to follow along with this course but just know that rules are there to provide fine grain access control over who can read a document or write to a document so that's firestore to very high level in the next video we'll see how it compares to traditional relational databases like SQL
Firestore vs SQL
web development I learned how to model data in relational databases usually postgres or MySQL relational databases are normalized which means they try to break down the data into as many small parts as possible so there's no data duplication a Rowan and SQL table can be thought of as a document and a firestore collection the document ID would be like the primary key on a table then we could reference other ideas inside that document just like we would with foreign keys in an SQL table but here's the catch there are no joins and Firestorm at least not in the traditional sense by sending a joint query to the database itself we can still join data together efficiently by making requests from the client which we'll look at later in the course and the reason we don't have joints and firestore or any no SQL database for that matter is because they're extremely inefficient as the creation of user data has become more and more prolific with apps like Twitter Facebook Snapchat etc it's been hard to operate SQL databases at scale because they require a lot of CPU resources to perform those joints so one of the driving forces behind no SQL or firestore is to design your data in such a way that it doesn't require a join we'll look at exactly how to do this later but at least me to probably what's the single most important concept in this course and that's to model your data based on how it's going to be consumed by the app before you make any data modeling decisions think about the screens in your mobile app or the pages on your website then design your data model to be the path of least resistance to get that data in that view I'll be repeating this later because it's a very important concept in a differs from SQL databases where you design your data model based on some preset rules this actually makes data modeling much more challenging in firestore when compared to a relational database you have to think strategically about how the data is going to be consumed and there's almost always more than one right way to do something so you have to consider the trade-offs between the various data models that you have at your disposal another major difference between buyer store and a relational database is the fact that firestore is schema less this means you can just add data to any document on the fly and it doesn't have to match the data types in the other documents in that collection this of course is different than SQL which has a predefined schema which forces you to adhere to a specific data type and a specific database structure for every table in the database buy your store also has some special data types that you won't find in most of the databases and that's exactly what we're going to look at in the next video


Data Types
types that are similar to data types and most other programming languages with a few special use cases in there as well the first thing we'll do is go into the firebase console and create a new collection called users the only required piece of information is a document ID screen firestore will create this for you automatically or you can create it yourself it just needs to be unique to this collection now the fields are key value pairs where the field name will always be a string and then that data type is one of the data types that you see in as list there's a few very simple data types things like strings numbers and booleans so let's start there first we'll define a weight on the document of 175 as a number and then we'll go ahead and create a second document with a different ID and then we'll also define a weight field there that has a different value firestore will automatically index all the fields on the document which means you can query them sort them and filter them and you can actually generate queries directly from the firebase console by clicking this icon on top of the collection we can use weight as the field and then we have various logical operators that we can use to sort or filter these documents if you want to filter the documents based on a specific value you can use the equal to operator if we set an equal to 175 it's only going to return the one document that has that value but if we use greater than or equal to it's going to include the document that has 175 as well as all of the documents that go above that value so those primitive values are pretty self-explanatory and you probably recognize them if you've ever worked with a different database but there's a few special data types and virus store that you might not recognize the first one is the geo point which is you specifically for geolocation data by saving a latitude and longitude the next one is a reference which is a reference to another document in the database you would think this would be useful for relational data modeling but you can also just save a document ID as long as you know which collection that it lives in this is mostly useful if you have a very deeply nested document and you want to keep a direct reference to it in my personal work I haven't come across any strong use cases for this so you're not going to see it in this course but just know that it's there if you want to use it now there are two data types that are especially useful for relational data modeling the first one is a map which is a key value pair that you can embed directly on a document a map is like an object in Javascript or a hashmap in most other programming languages as an example here we could use a map to save the users address in an SQL database we would typically normalize this data by creating a table for addresses and then associate them to a user with a primary foreign key pair but in firestore we can denormalize this data by Simply embedding it on the user document itself and the cool thing about this is that firestore will actually index the fields on the map as well so we could actually use the model that we're looking at here to query all the users that live at a specific zip code like I said before Maps are very powerful for relational data modeling and you'll see them used in many of the examples later on in the course and the last data type that you'll want to know about is an array the realizing to maintain a unique set of values that are ordered in some way we can use this to embed raw data on the document but we can also use it if we want to normalize data and then join it with a different front end query for example if we add a list of friends here and we wanted to query all of the users friend those are the data types that you need to know about in firestore and the next section we'll look at some of the core techniques used to model relational data
Techniques
techniques that will be combining in different ways throughout this course or relational data modeling the first technique is embedding which just means adding data directly to a document for example we might have a post collection and then inside of a document will have a field called tags and we'll put all of our tags directly in the document instead of normalizing them to their own collection this is typically the first technique you should consider because it's the most performance and also the most cost effective because the only need one document read to get all of your data but it's really only practical if you have a data set that's small enough to fit within one megabyte and you also don't have the ability to query any embedded data so you just have to read the entire document every time you want to access it technique number two is to create a root collection instead of embedding the data we'll give each target's own document in another root collection and then reference its ID in the post document so we create a tag document called cool and then provide these same data that we had in the embedded map in the previous example with tags we have a many to many relationship where a tag has many posts and a post has many tax an individual post will be only have one to five tags on it if you think of something like Twitter but a tag might have thousands or millions of posts associated with it with a root collection we can maintain the relationship by Simply referencing the tag IDS on the post document since we have multiple tags we'll go ahead and use an array but if you just have one tag or if you just have a one to one relationship you could just use a property on the document so now we know the name or idea of the tags that we want to use and we can pull in those documents individually if we need them for a specific view root collections are really nice because they have a lot of flexibility when querying across multiple properties but another technique is to nest this data as a sub collection this will scope the data to an individual document but we only actually read the data if we request it specifically so we'll click the add collection button inside of this document and then create a new collection called tags you'll notice that there's a path that starts at post goes to the Post ID and then to the tax collection under the document the next thing about a sub collection is that our one to many relationship between posts and tags is just set up implicitly because we can just reference this collection from beneath the document so we don't need to set up that array of tag IDS like we did with the root collection example but you have to be careful with sub collections because you can't query them across other collections at the same level so for example if we had another post that also had a tag sub collection we wouldn't be able to query across some shared property across those sub collections and will it closer at that when we get to the one to many section now the next technique is one that doesn't really have an official name but I like to call it bucketing with embedded data we have one document read but we might be pulling in some data that we don't actually need with a collection we might need to make multiple document reads just for a small amount of data so a bucket is sort of a trade-off between these two where we create a new document in a different collection but that document has all of the relational data embedded on it we'll go ahead and do this as a root collection so we'll create a collection called tags in the will create a document ID that matches the ID of the Post document so we have two documents with the same ID in the tags collection and one in the post collection so if we want to read the data for a post we grab the post by that ID
and if we also want to show the tag data in that screen or that view then we can read the tag document as well with the same exact idea in other words you have one document to show the main Post data and then you have a second document called tags which is just there to hold the relational data so if you had a post with 50 tags on it you could display all the data with just two document reads instead of 51 document reads so embedding root collections sub collections and bucketing are the four main techniques that will be combining throughout this course to build increasingly complex data models but before we get to that point we need to understand how firestore queries work and what their limitations are
Dmytro Smart, [08.10.2023 14:46]
Resources
a couple things you need first of all you'll need a firebase project and you want to make sure you have firestore enabled as your database in that project in many of the examples we'll be looking at the actual queries that we use to access the data in the database all that code is written in Javascript and you can find these Source Code in the github link below even though the queries are written in Javascript they're very similar for other languages like Swift or kotlin or dart if you're using flutter a lot of developers will be using firebase with a supporting library like angular fire or viewfire on the web so I'm going to keep this Source Code is simple as possible so you can modify the queries to work with whatever language or framework that you're using in fact I would recommend that you follow along with this video using your framework or language of choice then use the JavaScript code as a guide to point you in the right direction but if you do want to follow along with the vanilla JavaScript you can clone the repo and then add your firebase credentials to the config.js file in addition to the resources on fireship IO I also have a couple of articles on angular firebase.com that covered data modeling these articles are written when firestore was in beta but there's still relevant for the most part the firebase team also recently released a video series called getting to know cloud firestore if you haven't seen that already I highly recommend watching it that video series will have some overlap with this course but we'll be pushing things a lot farther and another resource I recommend is just data modeling articles on mongodb there's a lot of articles out there and I'm not going to recommend anything specific but mongodb sure is a lot of similarities with Firestorm so a lot of the data modeling Concepts apply they're both document oriented databases so at a very high level we can apply a lot of the same Concepts even though they're not a perfect one to one comparison and lastly the cloud firestore documentation is very thorough and very good it's very limited on data modeling which is one of the reasons I'm making this course but make sure to bookmark it for whatever language or framework you're using so those are the resources you'll want to have by your side for this course in the next video we'll look at what firestore actually is
Intro-what-is-firestore
when firebase was founded all the way back in 2011 it was designed to be a service for mobile applications for building chat applications but what the founders and developers realized is that people were using it for more than just chat applications and using it as a real-time database in general around the same time JavaScript frameworks like angularjs were starting to take off and there was kind of a gold rush going on with native app development for iOS and Android because of this developers needed to focus on optimizing the user experience with front end development services like firebase took off because it allowed users to easily create real-time applications without all of the back end configuration that goes along with it over the next few years firebase continued to grow and it was eventually acquired by Google and October of 2014 now the original database environments was the real-time database it's still a great product and it's not deprecated and not going anywhere and it's actually superior to firestore in certain use cases which will look at here later in the course but it has some limitations that really frustrated developers the database itself is basically just like a giant json object and you can select data at different nodes in this object but the main issue is that you cannot select a subset of this data so if you have a lot of data say 100 megabytes nested below a parent object you would have to pull all that data when reading the parent and then the second issue is that the querying and sorting of data is relatively limited so even if you denormalize your data to solve the first problem you'd still be in a situation where you have to write a lot of client side code to handle things like sorting and filtering of data cloud firestore was created to address these issues it's a document oriented database which is based off of Google's data store database technology which is used in all kinds of Google products like Gmail for example so firespur basically takes the real-time nature of the real-time database think combines it with more practical and flexible data access patterns firestore itself is a document oriented database similar to mongodb first we have collections and collections are just a container that hold documents a collection itself doesn't contain any data it just a name or a path to its location all of the actual data that we're going to use in our applications is contained in the document a document is basically just an objective data that has a unique ID and to access that data we can just read the document directly or we can query a subset of documents based on some shared properties and another unique characteristic of Firestorm is that we can nest collections underneath documents the result is that we have this alternating pattern of collections and documents and when we read a parent document that read a shallow so we don't have to pull in all the data contained in that child collection and that essentially forces us to model data that's efficient to read on the front end the maximum size of an individual document is one megabyte that gives you a lot of room to model your data but at the same time it prevents you from making inefficient queries that send a huge payload of data over the network that's how the overall database is structured but firestore also provides a mechanism for you to handle security I'm not going to cover how to write security rules in detail in this course but we will be talking about how to model data around security concerns you can view the rules here under the rules tab and I'd recommend just keeping your database in a completely unlocked mode to follow along with this course but just know that rules are there to provide fine grain access control over who can read a document or write to a document so that's firestore to very high level in the next video we'll see how it compares to traditional relational databases like SQL
Firestore vs SQL
web development I learned how to model data in relational databases usually postgres or MySQL relational databases are normalized which means they try to break down the data into as many small parts as possible so there's no data duplication a Rowan and SQL table can be thought of as a document and a firestore collection the document ID would be like the primary key on a table then we could reference other ideas inside that document just like we would with foreign keys in an SQL table but here's the catch there are no joins and Firestorm at least not in the traditional sense by sending a joint query to the database itself we can still join data together efficiently by making requests from the client which we'll look at later in the course and the reason we don't have joints and firestore or any no SQL database for that matter is because they're extremely inefficient as the creation of user data has become more and more prolific with apps like Twitter Facebook Snapchat etc it's been hard to operate SQL databases at scale because they require a lot of CPU resources to perform those joints so one of the driving forces behind no SQL or firestore is to design your data in such a way that it doesn't require a join we'll look at exactly how to do this later but at least me to probably what's the single most important concept in this course and that's to model your data based on how it's going to be consumed by the app before you make any data modeling decisions think about the screens in your mobile app or the pages on your website then design your data model to be the path of least resistance to get that data in that view I'll be repeating this later because it's a very important concept in a differs from SQL databases where you design your data model based on some preset rules this actually makes data modeling much more challenging in firestore when compared to a relational database you have to think strategically about how the data is going to be consumed and there's almost always more than one right way to do something so you have to consider the trade-offs between the various data models that you have at your disposal another major difference between buyer store and a relational database is the fact that firestore is schema less this means you can just add data to any document on the fly and it doesn't have to match the data types in the other documents in that collection this of course is different than SQL which has a predefined schema which forces you to adhere to a specific data type and a specific database structure for every table in the database buy your store also has some special data types that you won't find in most of the databases and that's exactly what we're going to look at in the next video
Data Types
types that are similar to data types and most other programming languages with a few special use cases in there as well the first thing we'll do is go into the firebase console and create a new collection called users the only required piece of information is a document ID screen firestore will create this for you automatically or you can create it yourself it just needs to be unique to this collection now the fields are key value pairs where the field name will always be a string and then that data type is one of the data types that you see in as list there's a few very simple data types things like strings numbers and booleans so let's start there first we'll define a weight on the document of 175 as a number and then we'll go ahead and create a second document with a different ID and then we'll also define a weight field there that has a different value firestore will automatically index all the fields on the document which means you can query them sort them and filter them and you can actually generate queries directly from the firebase console by clicking this icon on top of the collection we can use weight as the field and then we have various logical operators that we can use to sort or filter these documents if you want to filter the documents based on a specific value you can use the equal to operator if we set an equal to 175 it's only going to return the one document that has that value but if we use greater than or equal to it's going to include the document that has 175 as well as all of the documents that go above that value so those primitive values are pretty self-explanatory and you probably recognize them if you've ever worked with a different database but there's a few special data types and virus store that you might not recognize the first one is the geo point which is you specifically for geolocation data by saving a latitude and longitude the next one is a reference which is a reference to another document in the database you would think this would be useful for relational data modeling but you can also just save a document ID as long as you know which collection that it lives in this is mostly useful if you have a very deeply nested document and you want to keep a direct reference to it in my personal work I haven't come across any strong use cases for this so you're not going to see it in this course but just know that it's there if you want to use it now there are two data types that are especially useful for relational data modeling the first one is a map which is a key value pair that you can embed directly on a document a map is like an object in Javascript or a hashmap in most other programming languages as an example here we could use a map to save the users address in an SQL database we would typically normalize this data by creating a table for addresses and then associate them to a user with a primary foreign key pair but in firestore we can denormalize this data by Simply embedding it on the user document itself and the cool thing about this is that firestore will actually index the fields on the map as well so we could actually use the model that we're looking at here to query all the users that live at a specific zip code like I said before Maps are very powerful for relational data modeling and you'll see them used in many of the examples later on in the course and the last data type that you'll want to know about is an array the realizing to maintain a unique set of values that are ordered in some way we can use this to embed raw data on the document but we can also use it if we want to normalize data and then join it with a different front end query for example if we add a list of friends here and we wanted to query all of the users friend those are the data types that you need to know about in firestore and the next section we'll look at some of the core techniques used to model relational data
Techniques
techniques that will be combining in different ways throughout this course or relational data modeling the first technique is embedding which just means adding data directly to a document for example we might have a post collection and then inside of a document will have a field called tags and we'll put all of our tags directly in the document instead of normalizing them to their own collection this is typically the first technique you should consider because it's the most performance and also the most cost effective because the only need one document read to get all of your data but it's really only practical if you have a data set that's small enough to fit within one megabyte and you also don't have the ability to query any embedded data so you just have to read the entire document every time you want to access it technique number two is to create a root collection instead of embedding the data we'll give each target's own document in another root collection and then reference its ID in the post document so we create a tag document called cool and then provide these same data that we had in the embedded map in the previous example with tags we have a many to many relationship where a tag has many posts and a post has many tax an individual post will be only have one to five tags on it if you think of something like Twitter but a tag might have thousands or millions of posts associated with it with a root collection we can maintain the relationship by Simply referencing the tag IDS on the post document since we have multiple tags we'll go ahead and use an array but if you just have one tag or if you just have a one to one relationship you could just use a property on the document so now we know the name or idea of the tags that we want to use and we can pull in those documents individually if we need them for a specific view root collections are really nice because they have a lot of flexibility when querying across multiple properties but another technique is to nest this data as a sub collection this will scope the data to an individual document but we only actually read the data if we request it specifically so we'll click the add collection button inside of this document and then create a new collection called tags you'll notice that there's a path that starts at post goes to the Post ID and then to the tax collection under the document the next thing about a sub collection is that our one to many relationship between posts and tags is just set up implicitly because we can just reference this collection from beneath the document so we don't need to set up that array of tag IDS like we did with the root collection example but you have to be careful with sub collections because you can't query them across other collections at the same level so for example if we had another post that also had a tag sub collection we wouldn't be able to query across some shared property across those sub collections and will it closer at that when we get to the one to many section now the next technique is one that doesn't really have an official name but I like to call it bucketing with embedded data we have one document read but we might be pulling in some data that we don't actually need with a collection we might need to make multiple document reads just for a small amount of data so a bucket is sort of a trade-off between these two where we create a new document in a different collection but that document has all of the relational data embedded on it we'll go ahead and do this as a root collection so we'll create a collection called tags in the will create a document ID that matches the ID of the Post document so we have two documents with the same ID in the tags collection and one in the post collection so if we want to read the data for a post we grab the post by that ID
and if we also want to show the tag data in that screen or that view then we can read the tag document as well with the same exact idea in other words you have one document to show the main Post data and then you have a second document called tags which is just there to hold the relational data so if you had a post with 50 tags on it you could display all the data with just two document reads instead of 51 document reads so embedding root collections sub collections and bucketing are the four main techniques that will be combining throughout this course to build increasingly complex data models but before we get to that point we need to understand how firestore queries work and what their limitations are
Read
now we're going to look at some code used to query data from a firestore collection if you're dealing with embedded data the only thing you need to know is the document ID and then you can execute a read on that document this code is really as easy as It Gets we just reference the collection we'll call that collection post and then we reference the document by its ID in the following code snippets I'm only going to show you the actual access pattern to reference the data but if you want to actually read it you can call get to return it as a promise in Javascript or you can call on Snapchat to get a real-time stream of the data and a general rule of thumb that I follow with data modeling is that if my query code is very concise and readable then it means I probably have an effective data model but if my query code is really complex doing all kinds of joints and all kinds of other crazy logic that means I might want to rethink the data model that's just a general to follow and apps get very complex so you're not going to be able to do a simple document read for every single thing but you should definitely strive Force simplicity with your front end code sub collections are also nice and simple because if we already know the document ID then all we have to do is reference the collection that lives below that documents by calling collection now if we use the bucketing strategy that we looked at in the previous video that also wins itself to very simple queries instead of making a single document read we just make two document reads and we can run these concurrently using the same matching document ID in this case we have an extra document read but if we're only showing tags on a small subset of the actual views and the app then it probably makes sense to separate this data into its own document in a different collection the next thing I want to show you is how to read multiple documents when you have an array of IDS this is extremely useful and something that a lot of people don't even realize that you can do in firestore the firebase SDK under the hood does something called pipelining so if you make multiple requests at the same time it will combine all those requests and run them concurrently let's imagine we have a post document and on that document we have an array of tags with the tag ID and our goal is to query the tags collection with this array of IDS and return an array of tag documents so I'm kind of using JavaScript pseudo code here but if you imagine writing an async function we would first await the results of the read of the document and that gives us an array of tag IDS but we need the actual information saved on each individual tag document what we can do is map those IDS to an array of promises that read from the tags collection with each individual document ID now we have an array of promises and we can read all those promises concurrently by using promise.all and that will give us an array of the document snapshots from the database this is a very useful piece of code and I've actually requested that they implement this directly in the firebase SDK but as of today it's not a feature in the SDK I'll go ahead and post this helper function called read IDS below which allows you to pass in a collection name and an array of IDS and it will handle all the logic that we just went over this will only work for a single reads with promises but you can do similar things with our XJS if you want to handle our real-time stream that's how you perform individual document reads in the next section we'll look at how we can query filter and sort collections
Query
firestore when you run queries on collections in this section we'll look at the thing is that you can and cannot do with firestore brands to make a query you start by making a reference to a collection like the post collection and one of the most useful methods that you'll find is ordered by just like it sounds it returns the collection in a specific order and does all that ordering for you server side so you don't have to worry about it client side and you can always pass a second argument of desc for descending because the default is ascending it's also important to point out that order by can be used as a filtered as well for example if you order by a property that only exists on a subset of documents it will filter out all the documents that don't contain that property and when making queries and firestore keep in mind that you can chain together additional methods as needed for example if we want to limit this result to 20 items we can just say limit 20 and we'll only perform 20 document reads and get 20 documents back from our query in addition to limiting our documents we can also paginate them let's say we first order the documents by a date and then we can start after the date of last week start after his exclusive which means it's going to give us everything after last week but not include last week if we did want to include last week we get these start at that would make this query inclusive giving us everything from last week and beyond we can also paginate in the reverse Direction by using Nat which is the inclusive version or end before for the exclusive version the other query method in firestore is where and this is the one you'll probably be using more than all of the others the method itself takes three arguments the first argument is the field that you want to filter by the second argument is an operator that can be equal to greater than or equal to less than or equal to etc these operators work on numbers of course but you can also use them on streams and time stamps and other values as well and lastly the third argument is the value that you want to compare to so if we wanted to get all the posts that were posted today we could do a query of where the date is equal to today we can also chain multiple where statements together which will give us a logical and query if your filtering by multiple values you may need a composite index which will look at in the next video and keep in mind that you can only use at most one range operator per query you can use as many equal to operators as you want though but another limitation is that there is known not equals to operator however we can simulate a not equals to query by Simply making two queries and then combining them for example if we wanted all the documents where the name does not equal J we could just create two separate queries that use range operators and then combine them after these documents are red so that gives us everything above J and everything below J and the other thing that's not directly supported which you may be used to from an SQL database is the orc clause however keep in mind that you can always create multiple queries and combine them client side the two queries that we just made are essentially identical to an or clause because we requested all the documents that are above J or below J so when modeling your data always keep in mind that you can make multiple queries to get the data in the format that you need it's often easier to just maintain small simple queries than it is to try to create one big giant query that does everything that you need it to do now before we move on to the next video I also want to show you this array contains operator it's a special operator that will only work on the array data type and it will check that array to see if a certain value exist in there and only return the documents that happened to hatch a rate contains has be limitation of only being able to check for one value at a time but it is a very useful tool and you'll see it in some of the upcoming examples


Indexes
in order to query something efficiently at scale it needs to have an index by default Firestorm will create an index for all the properties on your document that makes it really easy to just query pretty much anything without having to think about it but if you want to create an index for multiple properties for example if you wanted to query all the documents that are greater than a certain value and also equal some other value and you'll need to tell buyers store to specifically index those properties together you can create indices manually by going to the indices tab on the firestore console this is an okay way to do things if you want to plan ahead but a better way to do it is just to write the code in your client side app and it will actually throw an error and give you a link to create that index for example if we try to make this query in a web application we would open up the console and see an error like this with a link back to the firebase console telling us to creating index if we go ahead and create that index it will take a few minutes to create and then we'll have something that looks like this on the index page in the console so I highly recommend just making this an automated process where you let the firebase SDK tell you when you need an index so that's how you manage your indices in the next video we'll take a look at how security plays a role in data modeling
Security
we're not going to cover how to write security rules in this video but the security needs for your application can definitely have an impact on how you model your data the most important thing to keep in mind is that you cannot partially read a document if you read a document you have to read the entire thing this comes into play in most apps when you start talking about user created data you as a developer are required to protect the privacy of your users and you definitely don't want to expose things like email addresses or phone numbers that could be scraped and then be used to spam your users so you may need to model your user data in separate collections for example here we have an account collection and this is the most secure collection in the database the read write rules are set to false which means it can't be read or written to from a client-side app so it's really only there for internal purposes to use on the back end the second collection is the users collection and you might want to use this for user data that's created by the user that owns it but you don't want anybody else to see it this is likely a collection where you would say things like a private email phone number etc and lastly we have this profiles collection and this is where we would save any public data so this is data that can only be written to by the user that owns it but it can be read by everybody in the app so this collection will be useful for things like usernames Avatar images and stuff like that the bottom line here is that if you have data that you don't want to expose client side you'll definitely want to make sure to isolate it in its own specific collection with its own security rules
Cardinality
things to ask yourself is how many items can be in a set is it one to a few is it one to a few hundred or is it 1 to a few million the answer this question will help drive your data models let's imagine we have an authors collection and at most every author will have maybe 20 books if the data payload for each individual book is fairly small like in this case we just have a title and a published attribute then it probably makes the most sense to embed it on the parent document especially if you're app will be frequently showing the books that are authored by this user because we just have a single document read two populate all the data we need for this author but maybe authors can have hundreds of books or maybe the data payload for each individual book is just too big to embed on an individual document and that case you might want to look into a bucket document for the author's books this would be a good strategy if you know that all of the book data can still fit into one megabyte and you don't really need to query the books in any sophisticated kind of way we can create that many relationship where an author has many books by using the same document ID for the authors document and the book document now just for conceptual purposes imagine that an author can write millions or a billions of books when you have a set with high cardinality it almost always means you want to collection it could be a sub collection or a root collection but collections can scale up to it unlimited number of documents and they can still be query efficiently when it comes to performance the size of the collection doesn't matter the only thing that really matters is the amount of data that you're sending over the network so don't be afraid to create large collections as needed in the next video we'll take a look at a one-to-one relationship and our options for modeling it and firestore
One-to-One
relationships are by far the easiest to model so we'll go through this video pretty quick let's imagine we have an authors collection and we have some account data that we want to save about that user the first thing we'll likely want to consider is whether or not we want to expose that data in the front end if the data in that relationship is perfectly fine to expose in the front end then I would say go ahead and embed it on the parent document like we are in this example but if some of that data is sensitive then we'll want to separate it out into its own document in a different collection and the way we connect that data as a one-to-one relationship is by using the same document ID in both collections but if we didn't want to use the same document ID maybe we have a different idea in mind that we need to use for that account we can still create a one-to-one relationship by Simply saving the document ID as a field on the author's document this method is slightly less efficient because we first have to read the authors document and then we'll get the ID and then make a secondary Reading to the account that's probably not a very big deal in most cases but it is a little bit of complexity that you want to avoid if you can and also when you use a shared document ID it enforces uniqueness on this relationship if it's truly a one-to-one relationship then you don't want to accidentally create an additional account for the same user and if you use the same shared top-level document ID then that would be impossible to do let's go ahead and compare these one-to-one models with some code the first example where we embed all of the data on a single document is just a simple document then if we share an ID between two different collections it's almost just as easy except this time we're reading two dogs instead of one now the third model is a little more complex because we first need to be authors document and then that will give us the account ID which we can then read with a separate read after the fact I'm doing that inside of an asynct function here in Javascript and if you're an angular user with rxjs you're probably used to doing this inside of switchmap on an observable but the general ID here is that we need to wait for the first request to resolve and give a data that will have the account ID which we can then use to make a second request to the database to join the extra data that we want that's how you set up a one-to-one relationship in the next video we'll start looking at one to many
One-to-Many
probably the most common data relationship and there are many different ways to model it the important thing to understand is the trade-offs when you choose a specific data model on firestore the first option is simply to embed an array of maps on the parent document this is great when you have a small number of items in the set and you also don't need to query those items across some other parent documents but what if we wanted to query all of the books that were published on a specific date or published after a certain date with our current data model we wouldn't be able to do that efficiently we would have to query all of the author documents and then do all of that filtering client side that's obviously not ideal so one of the first questions you should ask when dealing with a wonder many relationship is do I need to query the data if the answer is yes then the next thing you might want to consider is a sub collection but if you put the data in a sub collection the thing you'll need to keep in mind is that you can only query scope to this particular author so we would be able to query all the books published in 1971 but they would only be the books written by Dr Seuss or whatever author's sub collection that we're querying and that leads me to the next question you should ask is do I need to query across multiple parents and this example we might want to query all the books written on a specific date across all authors in the entire database if that's the case then we want to model our books as a root collection then for each book documents we'll add an author field that references the author document ID in general this tends to be the most flexible way to model a one to many relationship and it's also the most flexible approach so if we're not sure how our data model is going to unfold in the future this model will allow us to set up additional relationships in the future so let's go ahead and look at the query code for these various approaches obviously in Betty in the data on the document itself is going to be very easy to stay single document read and then if we have a sub collection that's almost just as easy we reference the parent document and then we go and reference piece of collection Now by creating a more flexible data model what they root collection we now have a slightly more complex query to make and our front end code if we want to get all the books by a certain author will first make a reference to the books collection and then we'll say where author equals the corresponding authority then we can change another wear method that will filter the books that are published after 1971 just keep in mind this is a compound queries so you'll need to create an index for this to actually work so those are your basic options for modeling a one to many relationship in the next video we'll look at many to many relationships
Many-to-Many
are very common and often the most complex relationships that you'll have to model let's imagine we have a books collection and an author's collection in the read of the database and then users can write reviews about books and we also want to enforce that users can only write one review per book we can create this relationship in a very normalized way using a Middleman collection called reviews you'll notice that books and authors don't have any data or knowledge about reviews so it is the responsibility of the review document to handle all of the information about the relationship and it doesn't that by saving an author ID and a book ID as Fields on the document on top of that it creates what's called a composite ID where we take the book ID and the author ID and then combine them together that will guarantee that a user can only create one review per bug if uses can create multiple reviews in your app then you can just have firestore create the automatic ID because at that point it doesn't really matter let's go ahead and jump into some code to look at how we can actually access this data now let's say we have a view that ship those all the reviews written by a specific user we can simply query the reviews collection and then filter it by the author is author ID and the cool thing about this model is we can do the same thing for books all we have to do is make the same query but filter it by the book document ID now if we already have a book ID and a user ID and we want to find that users review for a specific book we can do it with a single document read using that can pause that key so the takeaway here is that when you model your data as multiple root collections it gives you a lot of query flexibility that mean drawback with this model as that we need to execute a lot of document reads to get all the reviews in alternative approach here would be to embed the reviews directly on the book's document as a map on the bookstocument we have a property called reviews which is a map and then each key in that map is the corresponding user ID that wrote that Review this achieves the same thing that we did in the previous example with the composite ID it ensures that a user can only write one review per book but it also has the added benefit of allowing us to query all the books that a user has written a review for let's go back into our code and see how this affects the query if we want to get a book with all the reviews it's just a simple document read now so that gives us all the reviews for a specific book but what if we want all the reviews that were written by a specific user well the cool thing about firestore is that it will automatically index the keys on a map so we could use a where statement here or even easier we can use order by reviews the username and that will give us all the reviews that a user has written because if you remember from earlier ordered by a will filter out all the documents that don't have this property in other words we'll only get the books that have a review from this user ID a dropback of this approach is that we might be pointing in more data than we actually need for example if there's a lot of extra data on the books document then we're also going to get this when we're only trying to query the reviews for the user so you might be sending more data over the network than you actually need which is less efficient but ultimately you just need to weigh the pros and cons of the various trade-offs another common many to many relationship is something like categories or tags where a book might have many categories and a category might have many books in the books collection we'll have a field called categories which is an array and it keeps the ID of the categories document the category document has no knowledge of the relationship and it's really just there to hold additional metadata about a given category but then if you also have a screen for an individual category that shows all the books in that category you can easily make that query by using the array contains operator but keep in mind you can only make one array contains query at a time so it's not suitable for filtering multiple categories at once now the last relationship I want to look at is a many to many bucket so let's imagine we have a Middleman collection like we did in the first example but this time the purpose of the data is to just represent a connection between two documents something like likes or hearts or even up votes unlike a review on a book you're just using this data to toggle something on and off like you might show a different icon if they use our hearts something or if they haven't hardened something now let's imagine this book has a thousand hearts we can count all those hearts client side without having to do a thousand document reads and we can also use it as a manifest to determine all of the books that a user is liked and vice versa the issue here is that a document is limited to 20,000 properties or one megabyte so at the very most you'd be able to fit in 20,000 likes into a single document however in the next video we're going to look at some advanced techniques that we can use to supplement Our Data models to make them more efficient and more cost effective
Duplication
duplication if you come from an SQL background then you know that data duplication is something that you should never do but in no SQL and in firestore it's actually not a bad thing and when use properly it can actually save you necessary reads in the database now remember I mentioned earlier that we're trying to model Our Data to best fit the view and create efficiently ideally with just a single document read now if we look at the data model here we could easily maintain the one to many relationship between the user and the comments by Simply saving the user ID on the comment document but let's imagine that we also want to show the username for every comment in order to do that we'd also have to read the user document for every unique user that has commented on a given page so instead of reading all those documents each time we're just going to duplicate the username on every comment so now the comment document has all the data necessary to render the view without having to reach out and join data from the users collection data duplication makes a lot of sense when you have something that receives a lot of reads but not a lot of rights and in fact that's the way most data works because you're generally going to read data a lot more than you're going to change or modify data however you should avoid data duplication if you have a certain value that's going to potentially change frequently because that means you're going to have to hunt down every comment document anytime that data changes so in this case the username is a good candidate because the username is usually immutable and will never change but let's say we also wanted to duplicate this user's bio or profile on every comment well that's a value that might change frequently so if the user decides to change their bio then that means we have to query every comment and update it there as well so if you have a user with 5,000 comments and they decide to update their bio that means you're gonna perform biology reads and 5,000 rights just to get all of your data back in sync so in other words you're decreasing the complexity of the read but you're adding complexity to the right so you can have to weigh the trade-off there and it's usually best if it's a value that doesn't get written too frequently in the next video we're going to look at how we can incorporate cloud functions for data aggregation to further optimize the firestore database
Aggregation
calculating some value based on a collection of documents at this point I'm only introducing aggregation at a conceptual level if you want to learn how to write the actual code to perform data aggregation I'd recommend checking that out in the firestore section of the cloud functions master chords with Cloud functions you can listen to any change event on a document and then react by running some code in the back end one of the most common things to do is listen to the on creative event in an increment encounter in the back end that keeps track of the number of documents in a collection then at the same time also listen to on delete and then decrement it when a document is deleted but you can also use Cloud functions to do all kinds of other aggregation for example you might want to maintain some time series data about events that are going on in your application or maybe users pay for products on your site and you want to keep track of their order total on their user document so you don't have to count all their orders every time you want to show that in the video earlier I showed you a data model that used a Middleman collection to keep track of the number of alikes on a book this would be a great place to use data aggregation because we could use a cloud function that listens to this likes document and then we could add the total count of likes to the book document every time it changes so that way we never actually have to read from the likes document directly and that document is really only used by the cloud function to calculate the total which has been placed on the bookstocument so that decreases the total number of reads that we need on the front end and also sends a lot less data over the network in the next section we're going to look at a handful of different data models that use some combination of these techniques that we've looked at so far
Votes
a data model that's suitable for things like likes hearts and Reddit style up boats we looked at a very similar data model in the many to many section for the Middleman collection that handled reviews on books we have three root level collections on left we have users and on the user document we're also going to keep track of the total number of uploads of that user has received from other users then on the far right we have the post collection and that's going to keep track of the total number of upvotes on a given post then in the middle we have the votes collection where each document will take care of the relationship between these two outer collections for each vote document will assign a composite ID which starts with the user ID followed by an underscore and then the post ID and again that's done to automatically enforce uniqueness so the user can't vote more than once for the same post then on the post itself we'll have the value of the vote which can either be one zero or negative one and then we'll also include a post ID and a user ID so we can query all the votes for a given post or all of the boats for a given user if we need to and you can follow the green arrows in the diagram to see all of those connections now something you'll almost always want to do with a vote count is show the total number of votes for a given post or the user's total votes so we'll use a cloud function to aggregate that data whenever a new vote document has created when the document is created we'll go ahead and use the cloud function to add one or subtract one from the user document and do the same thing on the post document as well this allows our middle collection to scale up to millions and millions of documents but we only need to execute a single document read to show the total count on either the user or the post now just to put things in perspective if we didn't do this aggregation if we had 8,000 votes on a single post and then wanted to show the user account we would need to read a thousand documents just to generate that count and if we have 8,000 daily active users that means we would need to execute a million document reads just to generate the count on this one post so just to sum up here we're basically using the votes collection as a way to keep track of the relationship but it's not something that we actually show in the UI we delegate that word to either the user document or the post document which has all of the data necessary to render the UI
Role-Based Authorization
authorization in a firebase app the first step will be having the user login using one of the authentication methods like Google login or email password etc but after a user authenticates or logs in you may have additional user authorization logic to lockdown certain parts of the app most often the user authorization logic is tied to a payment for example on fireship when it uses signs that for a pro membership we open up access to different parts of the site like the very page that you're using to watch this video for example now there are two fundamental ways to model access control and firebase role-based and access control lists the first one will look at is role-based but I'd like to point out that firebase has an alternative to modeling based authorization in the database instead you can use custom claims directly on the user authentication record with this approach you need to write some back-end code to use the firebase admin SDK to add an additional object with some custom properties to the firebase auth record there are a number of trade-offs that they talk about in the documentation versus saving the user role in the database directly more than anything I just want to introduce custom claims as an alternative approach to modeling role-based authorization so you're aware that there's more than one way to tackle this problem the data model for a roll-based authorization is actually very simple we just have a user collection with a user document and in that document contains an array of roles and the rules are just defined as strings in this case and you can also define the rules as a map as well if you wanted to save additional information about each rule directly on the document and you might also want to separate the rules into a different collection if you don't want to expose the rules potentially to other users if you're showing like user profiles client side but in a lot of cases you might actually want to show the user role client side for example if you have a forum type app where you want to show who's a moderator who's an admin and stuff like that the important takeaway here is that it's the user document that defines what the user has access to this works really well when you have a generic type of system if you think of something like Netflix when you 
Access Control List
like I mentioned in the previous video role-based authorization is good when you have some global authorization rules that you can apply but if the content itself needs to define who has access to it than an access control list is what you want this is ideal when you have something this is ideal if you have something like a project management app where you have different groups and then those groups have certain members that can participate and it also works well if you sell something like a digital product and you only want to allow users that have paid for that item to be able to download it there are multiple different ways we can model this in this example here I have the members embedded directly on the post document but you could save this in a different collection and you could even save an access control list that is tied to a user so when we have the access control list tied to a post that post is going to save the user IDS that have access to the post but if we created an access control list for the user then we would say all of the posts that that user has access to under their access control list in general you want to save the relational data on whichever entity is going to have fewer relationships so in this example we only expect a few users to have access to a post so we just embed it directly on the post document but if there were potentially billions of users that needed access to this post then we want to save the access control list under the user because a user can only have a finite number of posts that they purchased let's go ahead and jump into our firestore rules to see how the rules like in this case a benefit of access control list is that we generally don't have to execute an extra document read if we embed these data directly on the Host document so if the user tries to execute a right we're going to look at the resource data and then the members array to see it that has the request auth user ID which is the currently logged in user so the user trying to write to this document can only execute the operation if their user ID already exists on the document and that access would usually be set up somewhere in your back end code for example the user makes a payment and then you go ahead and add their user ID to the document with the firebase admin SDK and one last thing I want to throw out there is that you can use a combination of both role-based off and access control lists if you want to in this model we have a user document that defines the user rules just like it didn't the previous example but the post also has an access control list but instead of defining user IDS it defines the roles that can take action on the document so this can be a really good approach when you have a roll-based system but maybe you have multiple groups that those roles apply to in the next video we're going to switch gears and talk about how to model a tree or a hierarchy or a thread instead of comments
sign up for a Netflix subscription that automatically gives you access to all of the videos that's a perfect use case for something like roll-based authorization but now you can contrast that with something like iTunes or Google Play where you pay to rent individual videos it will based system wouldn't really work there because it's the individual pieces of content that define who has access to them so we have a really simple data model here but it's the firestore rules that really make this work if we want to lock down the post collection we can do that by matching that path in the database and the first thing I'm going to do is write a function here that will get the user document so we can determine what role they have on that document I'll go ahead and paste this code below but basically we're going to make a reference to the user document in the database and then match it to the authenticated user ID and then we'll grab the rules property on that document the property is going to be an array and the array data type and fires store allows us to check if it has any value in it so we can do that by saying has any animal pass in whatever rules we want to allow to update this document so we might want the editor and admin users to be able to update the document but maybe we only want the admin user to be able to create new documents or delete documents this is nice because it's really simple and we're not required to write any back end code to secure the app but one of the drawbacks is that we have to execute a document read to check the roles every time a user tries to run an update or delete operation so if those extra document reads end up becoming a concern for you you might want to look into custom claims as an alternative in the next video we're g oing to look at an alternative to roll based authorization called an access control list
Hierarchy
is a tree or a hierarchy which is especially useful for doing things like threaded comments or maybe a deeply nested list of categories take for example the following model where we have a tree that's four levels deep each letter in the tree represents a different document and all these documents are kept in the same collection if you imagine this is a threat of comments you most likely want to query the first level of the tree so level one would be a and X and then you want to traverse down the tree only if the user clicks to open that comment to see the replies and you might want to continue following this pattern for multiple levels in the tree we can solve this Challenge by creating a composite key that references the parent documents each document will have a string field that references its parents in order if we go down to the bottom of the tree to the e node you'll see that the e-notes parents are a b d which you can follow all the way back to the top of the tree then for d it's just a b and so on the strings don't need to be an alphabetical order I'm just doing that for presentation reasons they will actually be query based on their length now I'm just kind of running through the database here you can see our a node has a parenth of false and then our v-node has a parent of a the c node has a parent of a b and so on if we were doing this with just regular automatically generated firestore IDS it would look something like this now one last thing I want to point out before we get to the code is that you can also save a level field on the document that tells you which level that note is in the tree you can inferly node by looking at the length of the parent field but it helps to just have that field as a number on the document and that will allow you to easily traverse the breadth or the width of the tree so if we imagine we're working with a set of threaded comments the first thing we'll likely do is grab the top level comments which we can do by making a query where the parent equals Falls if we want to make a query for if we want to make a query for all the documents add a horizontal level in the tree we can do that by Simply making a query for a level and pass it a number if you save that level field on the document I think a horizontal query is probably less useful in most cases especially if you're working with comments you'll probably want to traverse the depth of the tree so this is what we would want to do if the user clicks on a comment and then wants to see all the replies to that comment we can do this by making a query on the composite string that we added to the document that can pause it string will grow in length for each level in the tree which means we can make a query that's based on the length starting with the parent ID so the first query is for the parents where the composite string is greater than or equal to the ID and then we make a secondary range query where it's less than or equal to the ID plus a high unit code character this makes a query for a string that starts with the parent ID plus any strings that are longer than it which will be all the nodes nested underneath it if you use firestorms automatically generated IDS you're going to end up with something that looks like this and I have the idea separated by an underscore here and the cool thing about this technique is you can use it for more than just traversing trees for example I wrote this geofire x library that makes a similar query but does that with a geo-hashen algorithm so we can query adjacency based on bounding boxes on the GLobe this is definitely a more advanced technique but if you can embed patterns and strings then you can probably query them efficiently and firestore
Follower Feed
I think the single most challenging data model that will look at in this course is a social follower feed our goal in this video is to create a data model that allows users to follow each other while at the same time be able to see the most recent posts from the users that they follow in other words we're setting up a system somewhere to Twitter where you see a Beat of tweets from the people you follow when you go to your homepage in order to understand why this is so hard it's important to first look at the failed attempts my first idea was to simply create a collection similar to the vote model that we looked at a few videos ago to manage the Followers to following relationship between users this works well if you want to get all of the people that a user is following but the tricky part is getting all the post of those users if we look at a SQL query basically what we're trying to do is select all the documents from post where the user is in this array of user IDS this would be an okay thing to do if the user was following five users but if they're following 5 million users then there's no way it's going to work to get the most recent posts for users you would have to query every single user that that user is following and figure out their most recent posts and then sort of all client side so you'd have to read a huge amount of data that you don't actually need in the front end my next idea was to just do some mass duplication and create a timeline for each individual user then whenever one of the users that they're following posts some new content we'll just duplicate it on their timeline document or timeline collection the benefit of this is that it would be very efficient to read a user's timeline but the drawback is that it just doesn't scale if you do the math and specifically it doesn't scale in terms of pricing because if they user has say a million followers that means you'd have to update a million timelines every time they post something and if you have millions of users posting hundreds of times per day it's just not going to work so that brings me to Our Data model in our database we have three collections one for posts one for users and one for followers all of the relational data will be held on the Followers document and the Followers document alongs to the user who is being followed this document has three main purposes the first one is to keep track of all of the users that are following this user which we do on this user's property which is an array of strings next we have this recent post field which is an array of maps and each math is a duplicated post from the user's post collection so this contains information like the post ID maybe the time stamp and also the title and maybe some preview text if you want as well the cool thing about this model is that we're duplicating data but we only need to duplicate it in one place so when the user adds a new post we add it to the post collection and then we also duplicate it in there followers document so that's much more efficient than trying to duplicate it for every single follower and the third important property that you'll see here is the last post time stamp this will tell us when this user lasts posted or when their last activity was which allows us to query all of the recent posts from a collection of users that a user is following and that's all the problem that we faced in the first failed attempt where we have to query a whole bunch of data client side and then try to sort through it all manually let's take a look at the demo before we get into the code currently we're not following anybody so our feet is completely empty but then if we follow QE then we see all of huey's most recent posts in the feed and if we follow Dewey we see his post gets inserted here in the middle because his post came before huey's most recent post but now we have a feed of multiple users posts based on the user's that were following I'm going to go ahead and write this query inside of an async function because we'll need to do some data wrangling after we retrieve the initial data first we'll make a reference to the voller's collection and then we'll query it using a ray contains with the username of the logged in user after that we'll make this a compound query by using order by with the last post time stamp and keep in mind this is a compound queries so it's going to require an index and firestore will give you a warning about that in the console now the cool thing about this is we can limit it to 10 document reads so it's a very efficient read but it can provide us with data to populate potentially dozens of different posts in the field once we have the result of this query we have an array that we need to then map to the document data and then on the document data we're going to have an array of the user's most recent posts and that's what we actually want to be showing in the view so I'm going to reduce this array of documents down to a new array that only contains the recent posts and then I want to sort those resuppose based on their publish date we can use a race sort to handle that and at this point we now have a sort of array of post that spans across multiple users that this user is following




